// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// GenesisResponseAppState genesis response app state
//
// swagger:model GenesisResponseAppState
type GenesisResponseAppState struct {

	// accounts
	Accounts []*AppStateAccount `json:"accounts"`

	// block list candidates
	BlockListCandidates []string `json:"block_list_candidates"`

	// candidates
	Candidates []*AppStateCandidate `json:"candidates"`

	// coins
	Coins []*GenesisResponseAppStateCoin `json:"coins"`

	// commission
	Commission *AppStateCommission `json:"commission,omitempty"`

	// commission votes
	CommissionVotes []*AppStateCommissionVote `json:"commission_votes"`

	// deleted candidates
	DeletedCandidates []*AppStateDeletedCandidate `json:"deleted_candidates"`

	// emission
	Emission string `json:"emission,omitempty"`

	// frozen funds
	FrozenFunds []*AppStateFrozenFund `json:"frozen_funds"`

	// halt blocks
	HaltBlocks []*AppStateHaltBlock `json:"halt_blocks"`

	// max gas
	MaxGas uint64 `json:"max_gas,omitempty,string"`

	// next order id
	NextOrderID uint64 `json:"next_order_id,omitempty,string"`

	// note
	Note string `json:"note,omitempty"`

	// pools
	Pools []*AppStatePool `json:"pools"`

	// prev reward
	PrevReward *AppStateRewardPrice `json:"prev_reward,omitempty"`

	// total slashed
	TotalSlashed string `json:"total_slashed,omitempty"`

	// update votes
	UpdateVotes []*AppStateUpdateVote `json:"update_votes"`

	// used checks
	UsedChecks []string `json:"used_checks"`

	// validators
	Validators []*AppStateValidators `json:"validators"`

	// version
	Version string `json:"version,omitempty"`

	// versions
	Versions []*GenesisResponseAppStateVersion `json:"versions"`

	// waitlist
	Waitlist []*AppStateWaitlist `json:"waitlist"`
}

// Validate validates this genesis response app state
func (m *GenesisResponseAppState) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCandidates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCoins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommission(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommissionVotes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeletedCandidates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrozenFunds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHaltBlocks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePools(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrevReward(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdateVotes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidators(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWaitlist(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GenesisResponseAppState) validateAccounts(formats strfmt.Registry) error {
	if swag.IsZero(m.Accounts) { // not required
		return nil
	}

	for i := 0; i < len(m.Accounts); i++ {
		if swag.IsZero(m.Accounts[i]) { // not required
			continue
		}

		if m.Accounts[i] != nil {
			if err := m.Accounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("accounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validateCandidates(formats strfmt.Registry) error {
	if swag.IsZero(m.Candidates) { // not required
		return nil
	}

	for i := 0; i < len(m.Candidates); i++ {
		if swag.IsZero(m.Candidates[i]) { // not required
			continue
		}

		if m.Candidates[i] != nil {
			if err := m.Candidates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("candidates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validateCoins(formats strfmt.Registry) error {
	if swag.IsZero(m.Coins) { // not required
		return nil
	}

	for i := 0; i < len(m.Coins); i++ {
		if swag.IsZero(m.Coins[i]) { // not required
			continue
		}

		if m.Coins[i] != nil {
			if err := m.Coins[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("coins" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validateCommission(formats strfmt.Registry) error {
	if swag.IsZero(m.Commission) { // not required
		return nil
	}

	if m.Commission != nil {
		if err := m.Commission.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("commission")
			}
			return err
		}
	}

	return nil
}

func (m *GenesisResponseAppState) validateCommissionVotes(formats strfmt.Registry) error {
	if swag.IsZero(m.CommissionVotes) { // not required
		return nil
	}

	for i := 0; i < len(m.CommissionVotes); i++ {
		if swag.IsZero(m.CommissionVotes[i]) { // not required
			continue
		}

		if m.CommissionVotes[i] != nil {
			if err := m.CommissionVotes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commission_votes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validateDeletedCandidates(formats strfmt.Registry) error {
	if swag.IsZero(m.DeletedCandidates) { // not required
		return nil
	}

	for i := 0; i < len(m.DeletedCandidates); i++ {
		if swag.IsZero(m.DeletedCandidates[i]) { // not required
			continue
		}

		if m.DeletedCandidates[i] != nil {
			if err := m.DeletedCandidates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("deleted_candidates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validateFrozenFunds(formats strfmt.Registry) error {
	if swag.IsZero(m.FrozenFunds) { // not required
		return nil
	}

	for i := 0; i < len(m.FrozenFunds); i++ {
		if swag.IsZero(m.FrozenFunds[i]) { // not required
			continue
		}

		if m.FrozenFunds[i] != nil {
			if err := m.FrozenFunds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("frozen_funds" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validateHaltBlocks(formats strfmt.Registry) error {
	if swag.IsZero(m.HaltBlocks) { // not required
		return nil
	}

	for i := 0; i < len(m.HaltBlocks); i++ {
		if swag.IsZero(m.HaltBlocks[i]) { // not required
			continue
		}

		if m.HaltBlocks[i] != nil {
			if err := m.HaltBlocks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("halt_blocks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validatePools(formats strfmt.Registry) error {
	if swag.IsZero(m.Pools) { // not required
		return nil
	}

	for i := 0; i < len(m.Pools); i++ {
		if swag.IsZero(m.Pools[i]) { // not required
			continue
		}

		if m.Pools[i] != nil {
			if err := m.Pools[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pools" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validatePrevReward(formats strfmt.Registry) error {
	if swag.IsZero(m.PrevReward) { // not required
		return nil
	}

	if m.PrevReward != nil {
		if err := m.PrevReward.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("prev_reward")
			}
			return err
		}
	}

	return nil
}

func (m *GenesisResponseAppState) validateUpdateVotes(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdateVotes) { // not required
		return nil
	}

	for i := 0; i < len(m.UpdateVotes); i++ {
		if swag.IsZero(m.UpdateVotes[i]) { // not required
			continue
		}

		if m.UpdateVotes[i] != nil {
			if err := m.UpdateVotes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("update_votes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validateValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.Validators) { // not required
		return nil
	}

	for i := 0; i < len(m.Validators); i++ {
		if swag.IsZero(m.Validators[i]) { // not required
			continue
		}

		if m.Validators[i] != nil {
			if err := m.Validators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validateVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.Versions) { // not required
		return nil
	}

	for i := 0; i < len(m.Versions); i++ {
		if swag.IsZero(m.Versions[i]) { // not required
			continue
		}

		if m.Versions[i] != nil {
			if err := m.Versions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) validateWaitlist(formats strfmt.Registry) error {
	if swag.IsZero(m.Waitlist) { // not required
		return nil
	}

	for i := 0; i < len(m.Waitlist); i++ {
		if swag.IsZero(m.Waitlist[i]) { // not required
			continue
		}

		if m.Waitlist[i] != nil {
			if err := m.Waitlist[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("waitlist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this genesis response app state based on the context it is used
func (m *GenesisResponseAppState) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCandidates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCoins(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCommission(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCommissionVotes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeletedCandidates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFrozenFunds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHaltBlocks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePools(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrevReward(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdateVotes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWaitlist(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GenesisResponseAppState) contextValidateAccounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Accounts); i++ {

		if m.Accounts[i] != nil {
			if err := m.Accounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("accounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateCandidates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Candidates); i++ {

		if m.Candidates[i] != nil {
			if err := m.Candidates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("candidates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateCoins(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Coins); i++ {

		if m.Coins[i] != nil {
			if err := m.Coins[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("coins" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateCommission(ctx context.Context, formats strfmt.Registry) error {

	if m.Commission != nil {
		if err := m.Commission.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("commission")
			}
			return err
		}
	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateCommissionVotes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CommissionVotes); i++ {

		if m.CommissionVotes[i] != nil {
			if err := m.CommissionVotes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commission_votes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateDeletedCandidates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DeletedCandidates); i++ {

		if m.DeletedCandidates[i] != nil {
			if err := m.DeletedCandidates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("deleted_candidates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateFrozenFunds(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FrozenFunds); i++ {

		if m.FrozenFunds[i] != nil {
			if err := m.FrozenFunds[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("frozen_funds" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateHaltBlocks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HaltBlocks); i++ {

		if m.HaltBlocks[i] != nil {
			if err := m.HaltBlocks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("halt_blocks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidatePools(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Pools); i++ {

		if m.Pools[i] != nil {
			if err := m.Pools[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pools" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidatePrevReward(ctx context.Context, formats strfmt.Registry) error {

	if m.PrevReward != nil {
		if err := m.PrevReward.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("prev_reward")
			}
			return err
		}
	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateUpdateVotes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UpdateVotes); i++ {

		if m.UpdateVotes[i] != nil {
			if err := m.UpdateVotes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("update_votes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Validators); i++ {

		if m.Validators[i] != nil {
			if err := m.Validators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateVersions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Versions); i++ {

		if m.Versions[i] != nil {
			if err := m.Versions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GenesisResponseAppState) contextValidateWaitlist(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Waitlist); i++ {

		if m.Waitlist[i] != nil {
			if err := m.Waitlist[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("waitlist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GenesisResponseAppState) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GenesisResponseAppState) UnmarshalBinary(b []byte) error {
	var res GenesisResponseAppState
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
